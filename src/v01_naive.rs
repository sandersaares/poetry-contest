use std::{collections::HashMap, fs, path::PathBuf};

use serde::Deserialize;

use crate::find_workspace_root;

#[test]
fn run() {
    let result = solve();
    println!("{}", result);
}

/// Solves the poetry contest problem.
///
/// Prerequisites:
/// * Data set has been generated by executing `cargo run --example generate_data --release`.
///
/// Input is loaded from `data/manifest.json` located at the workspace root (the first directory
/// found to contain a `Cargo.toml` file when searching upwards from the current directory).
///
/// Expected output: total score of all authors.
///
/// Scoring:
///
/// 1. The manifest contains a set of categories used for scoring and a set of rounds (see
///    `examples/generate_data` for details on the data format and expected contents).
/// 2. Each round accumulates points for each author, the author's total score is simply the
///    sum of scores they receive from each round. We process each round individually - there
///    are no relationships between entries from different rounds, only authors and categories
///    exist in the scope of the entire problem.
/// 3. Each round contains a set of entries, each entry is associated with a single author and
///    any number of categories (from zero to all categories).
/// 4. If an entry is longer than 1000 bytes or has no non-whitespace characters, it is disqualified.
/// 5. If an entry exactly equals a different entry in the same round (regardless of author),
///    both are disqualified.
/// 6. The weight of an entry is defined as its word density - length in bytes divided by
///    number of words (a word is defined as a nonempty sequence of non-whitespace characters
///    separated by whitespace). By definition, an entry cannot have zero words (see rule 4).
/// 7. The categories of an entry are determined by matching the keywords of a category against
///    the words in the first line of the entry (or the entire entry if there are no line breaks).
///    A category matches if at least one keyword matches a word in the first line of the entry.
///    An entry can match zero or more categories.
/// 8. In each round, the entry with the highest weight in each category yields 1 point for its
///    author. The same entry may yield points for multiple categories. In case of a tie, all
///    authors with the highest weight receive 1 point. If the same author has multiple entries
///    in the tie, they only get 1 point total for that category.
pub fn solve() -> u64 {
    let workspace_root = find_workspace_root();
    let data_dir = workspace_root.join("data");
    let manifest_path = data_dir.join("manifest.json");

    let manifest_json = fs::read_to_string(&manifest_path).expect("Failed to read manifest.json");

    let manifest: Manifest = serde_json::from_str(&manifest_json).unwrap();

    // Build a HashMap for efficient keyword lookup
    // Key: keyword, Value: list of category indices that contain this keyword
    let mut keyword_to_categories: HashMap<&str, Vec<usize>> = HashMap::new();
    for (cat_idx, category) in manifest.categories.iter().enumerate() {
        for keyword in &category.keywords {
            keyword_to_categories
                .entry(keyword.as_str())
                .or_insert_with(Vec::new)
                .push(cat_idx);
        }
    }

    let mut points_by_author: HashMap<String, u64> = HashMap::new();

    for round_path in manifest.rounds {
        let round_file_path = data_dir.join(&round_path);
        let round_json = fs::read_to_string(&round_file_path).expect("Failed to read round file");
        let round: Round = serde_json::from_str(&round_json).unwrap();

        let mut active_entries = Vec::<ActiveEntry>::new();

        let mut remaining_entries = round.entries;

        while let Some(entry) = remaining_entries.pop() {
            // Verify that the entry is not disqualified due to length or emptiness.
            if entry.contents.len() > 1000 {
                continue;
            }

            if entry.contents.trim().is_empty() {
                continue;
            }

            // Verify that the entry is not disqualified due to duplication.
            // Note: disqualified sets can consist of more than 2 duplicates, so we
            // cannot immediately remove the existing entry, the best we can do is skip
            // adding the new entry and mark the existing one disqualified, so it can be
            // removed later.
            if let Some(existing) = active_entries
                .iter_mut()
                .find(|existing| existing.entry.contents == entry.contents)
            {
                existing.is_disqualified = true;

                // Skip adding the duplicate entry.
                continue;
            }

            active_entries.push(ActiveEntry {
                entry,
                is_disqualified: false,
            });
        }

        // Remove any that were disqualified and marked for deferred removal.
        active_entries.retain(|e| !e.is_disqualified);

        // Key: category index.
        // Value: (best weight, list of authors with that weight).
        let mut best_by_category: HashMap<usize, (f64, Vec<String>)> = HashMap::new();

        // For each active entry, determine its categories and weight, and update
        // the best_by_category map accordingly.
        for active_entry in active_entries {
            let first_line = active_entry.entry.contents.lines().next().unwrap(); // Safe, there is always at least one line.

            let words: Vec<&str> = first_line.split_whitespace().collect();

            let mut matched_categories = Vec::new();

            // Use the keyword lookup HashMap for efficient categorization
            for word in &words {
                if let Some(cat_indices) = keyword_to_categories.get(word) {
                    for &cat_idx in cat_indices {
                        if !matched_categories.contains(&cat_idx) {
                            matched_categories.push(cat_idx);
                        }
                    }
                }
            }

            if matched_categories.is_empty() {
                continue;
            }

            let weight = calculate_weight(&active_entry.entry.contents);

            for cat_idx in matched_categories {
                let entry_author = active_entry.entry.author.clone();

                let best_entry = best_by_category.entry(cat_idx).or_insert((weight, vec![]));

                if weight > best_entry.0 {
                    // New best weight, replace existing authors.
                    best_entry.0 = weight;
                    best_entry.1.clear();
                    best_entry.1.push(entry_author);
                } else if weight == best_entry.0 {
                    // Tie for best weight, add author if not already present.
                    if !best_entry.1.contains(&entry_author) {
                        best_entry.1.push(entry_author);
                    }
                }
            }
        }

        // Award points to authors with best entries in each category.
        for (_cat_idx, (_best_weight, authors)) in best_by_category {
            for author in authors {
                *points_by_author.entry(author).or_insert(0) += 1;
            }
        }
    }

    // Calculate final output: total score of all authors.
    points_by_author.values().copied().sum::<u64>()
}

fn calculate_weight(content: &str) -> f64 {
    let length = content.len() as f64;
    let word_count = content.split_whitespace().count() as f64;

    length / word_count
}

/// An entry under evaluation as part of a round.
struct ActiveEntry {
    entry: Entry,
    is_disqualified: bool,
}

#[derive(Deserialize)]
struct Manifest {
    categories: Vec<Category>,
    rounds: Vec<PathBuf>,
}

#[derive(Deserialize)]
struct Category {
    keywords: Vec<String>,
}

#[derive(Deserialize)]
struct Round {
    entries: Vec<Entry>,
}

#[derive(Deserialize)]
struct Entry {
    author: String,
    contents: String,
}
