use std::{collections::HashMap, fs, path::PathBuf};

use serde::Deserialize;

use crate::find_workspace_root;

#[test]
fn run() {
    let result = solve();
    println!("{}", result);
}

/// Solves the poetry contest problem.
///
/// Prerequisites:
/// * Data set has been generated by executing `cargo run --example generate_data --release`.
///
/// Input is loaded from `data/manifest.json` located at the workspace root (the first directory
/// found to contain a `Cargo.toml` file when searching upwards from the current directory).
///
/// Expected output: total score of all authors.
///
/// Scoring:
///
/// 1. The manifest contains a set of categories used for scoring and a set of rounds (see
///    `examples/generate_data` for details on the data format and expected contents).
/// 2. Each round accumulates points for each author, the author's total score is simply the
///    sum of scores they receive from each round. We process each round individually - there
///    are no relationships between entries from different rounds, only authors and categories
///    exist in the scope of the entire problem.
/// 3. Each round contains a set of entries, each entry is associated with a single author and
///    any number of categories (from zero to all categories).
/// 4. If an entry is longer than 1000 bytes or has no non-whitespace contents, it is disqualified.
/// 5. The weight of an entry is defined as its word density - length in bytes divided by
///    number of words (a word is defined as a nonempty sequence of non-whitespace characters
///    separated by whitespace). By definition, an entry cannot have zero words (see rule 4).
/// 6 The categories of an entry are determined by matching the keywords of a category against
///    the words in the title of the entry. A category matches if at least one keyword matches
///    a word in the title. An entry can match zero or more categories.
/// 7. In each round, the entry with the highest weight in each category yields 1 point for its
///    author. The same entry may yield points for multiple categories. In case of a tie in some
///    category, all authors with the highest weight receive 1 point for that category. If the
///    same author has multiple entries in the tie, they only get 1 point total for that category.
pub fn solve() -> u64 {
    let workspace_root = find_workspace_root();
    let data_dir = workspace_root.join("data");
    let manifest_path = data_dir.join("manifest.json");

    let manifest_json = fs::read_to_string(&manifest_path).expect("Failed to read manifest.json");
    solve_inner(data_dir, manifest_json)
}

fn solve_inner(data_dir: PathBuf, manifest_json: String) -> u64 {
    let manifest: Manifest = serde_json::from_str(&manifest_json).unwrap();

    // Build a HashMap for efficient keyword lookup
    // Key: keyword, Value: list of category indices that contain this keyword
    let mut keyword_to_categories: HashMap<&str, Vec<usize>> = HashMap::new();
    for (cat_idx, category) in manifest.categories.iter().enumerate() {
        for keyword in &category.keywords {
            keyword_to_categories
                .entry(keyword.as_str())
                .or_insert_with(Vec::new)
                .push(cat_idx);
        }
    }

    let mut points_by_author: HashMap<String, u64> = HashMap::new();

    for round_path in manifest.rounds {
        let round_file_path = data_dir.join(&round_path);
        let round_json = fs::read_to_string(&round_file_path).expect("Failed to read round file");

        solve_round(round_json, &keyword_to_categories, &mut points_by_author);
    }

    // Calculate final output: total score of all authors.
    points_by_author.values().copied().sum::<u64>()
}

fn solve_round(
    round_json: String,
    keyword_to_categories: &HashMap<&str, Vec<usize>>,
    points_by_author: &mut HashMap<String, u64>,
) {
    let round: Round = serde_json::from_str(&round_json).unwrap();
    let entries = parse_entries(round);

    // Key: category index.
    // Value: (best weight, list of authors with that weight).
    let mut best_by_category: HashMap<usize, (f64, Vec<&str>)> = HashMap::new();

    // For each entry, determine its categories and weight, and update
    // the best_by_category map accordingly.
    for entry in &entries {
        let words = entry.title.split_whitespace();

        let mut matched_categories = Vec::new();

        // Use the keyword lookup HashMap for efficient categorization
        for word in words {
            if let Some(cat_indices) = keyword_to_categories.get(word) {
                for &cat_idx in cat_indices {
                    if !matched_categories.contains(&cat_idx) {
                        matched_categories.push(cat_idx);
                    }
                }
            }
        }

        if matched_categories.is_empty() {
            continue;
        }

        let weight = calculate_weight(&entry.contents);

        for cat_idx in matched_categories {
            let entry_author: &str = &entry.author;

            let best_entry = best_by_category.entry(cat_idx).or_insert((weight, vec![]));

            if weight > best_entry.0 {
                // New best weight, replace existing authors.
                best_entry.0 = weight;
                best_entry.1.clear();
                best_entry.1.push(entry_author);
            } else if weight == best_entry.0 {
                // Tie for best weight, add author if not already present.
                if !best_entry.1.contains(&entry_author) {
                    best_entry.1.push(entry_author);
                }
            }
        }
    }

    // Award points to authors with best entries in each category.
    for (_cat_idx, (_best_weight, authors)) in best_by_category {
        for author in authors {
            // For lookup we use the &str because we expect the author is typically already in
            // the map (from previous rounds or entries). This avoids having to create a new
            // string for every lookup - we only create owned strings for insertion.
            if let Some(existing_entry) = points_by_author.get_mut(author) {
                *existing_entry += 1;
                continue;
            }

            // An existing entry did not exist, so insert a new entry.
            points_by_author.insert(author.to_owned(), 1);
        }
    }
}

fn parse_entries(round: Round) -> Vec<Entry> {
    round
        .entries
        .into_iter()
        .filter(|e| e.contents.len() <= 1000 && !e.contents.trim().is_empty())
        .collect()
}

fn calculate_weight(content: &str) -> f64 {
    let length = content.len() as f64;
    let word_count = content.split_whitespace().count() as f64;

    length / word_count
}

#[derive(Deserialize)]
struct Manifest {
    categories: Vec<Category>,
    rounds: Vec<PathBuf>,
}

#[derive(Deserialize)]
struct Category {
    keywords: Vec<String>,
}

#[derive(Deserialize)]
struct Round {
    entries: Vec<Entry>,
}

#[derive(Deserialize)]
struct Entry {
    author: String,
    title: String,
    contents: String,
}
